import random
import string
import time
import os
import sys

# === Utility Functions for File Management === #

def write_to_file(filename, content):
    """Writes content to a file."""
    with open(filename, 'w') as f:
        f.write(content)

# === 1. Basic Test Generator === #

def generate_random_integer():
    """Generates random integers: positive, negative, or zero."""
    return random.choice([random.randint(-1000, -1), 0, random.randint(1, 1000)])

def generate_random_string():
    """Generates random strings: empty, single character, or multiple characters."""
    options = [
        "",  # Empty string
        random.choice(string.ascii_letters),  # Single character
        ''.join(random.choices(string.ascii_letters + string.digits, k=random.randint(2, 20)))  # Multiple characters
    ]
    return random.choice(options)

def generate_random_array():
    """Generates random arrays with integers or strings (mixing both types)."""
    length = random.randint(1, 10)
    return [random.choice([generate_random_integer(), generate_random_string()]) for _ in range(length)]

def generate_random_boolean():
    """Generates random boolean values: True or False."""
    return random.choice([True, False])

# === 2. Simple Test Runner === #

def run_test(test_function, input_generator, num_tests=100, expected_output=None):
    """Runs a test function with inputs generated by the input generator."""
    passed, failed = 0, 0
    failure_cases = []

    for _ in range(num_tests):
        try:
            test_input = input_generator()
            result = test_function(test_input)

            # Compare result to expected output if provided
            if expected_output is not None and result != expected_output:
                failed += 1
                failure_cases.append((test_input, result))
            else:
                passed += 1
        except Exception as e:
            failed += 1
            failure_cases.append((test_input, str(e)))

    return {
        "passed": passed,
        "failed": failed,
        "failure_cases": failure_cases
    }

def run_test_with_metrics(test_function, input_generator, num_tests=100, expected_output=None):
    """Runs tests and records execution time."""
    start_time = time.time()
    results = run_test(test_function, input_generator, num_tests, expected_output)
    end_time = time.time()
    results["time_taken"] = end_time - start_time
    return results

# === 3. Result Reporting === #

def generate_report(results, description, manual_results=None):
    """Generates a detailed report for the test results."""
    report = [
        f"Description: {description}",
        f"Total Tests Run: {results['passed'] + results['failed']}",
        f"Passed: {results['passed']}",
        f"Failed: {results['failed']}",
        f"Time Taken: {results.get('time_taken', 'N/A'):.2f} seconds",
        "Failure Cases:"
    ]
    for case in results['failure_cases']:
        report.append(str(case))
    
    # Add comparison with manual testing
    if manual_results is not None:
        report.append("\nComparison with Manual Testing:")
        report.append(f"Manual Testing Total: {manual_results['total']}")
        report.append(f"Manual Testing Passed: {manual_results['passed']}")
        report.append(f"Manual Testing Failed: {manual_results['failed']}")
        report.append(f"Manual Testing Time Taken: {manual_results['time_taken']:.2f} seconds")
        report.append("\nManual Testing Inputs and Outputs:")

        # Adding manual test inputs, status (passed/failed) to the report
        for input_val, status in manual_results['inputs_outputs']:
            report.append(f"Input: {input_val}, Status: {status}")
        
        # Add array testing details to the report (if any)
        if manual_results.get('array_testing_details'):
            report.append("\nArray Testing Details:")
            for detail in manual_results['array_testing_details']:
                report.append(detail)
    
    return "\n".join(report)

# === 4. Evaluation Plan === #

def evaluate_with_metrics(test_function, input_generators, num_tests, output_dir, manual_results=None):
    """Evaluates multiple input types and writes results to files."""
    for input_type, generator in input_generators.items():
        description = f"Testing {test_function.__name__} with {input_type} inputs."
        print(f"\n{description}")
        results = run_test_with_metrics(test_function, generator, num_tests)
        report = generate_report(results, description, manual_results)
        
        # Write report to file
        output_file = os.path.join(output_dir, f"{test_function.__name__}_{input_type}_results.txt")
        write_to_file(output_file, report)
        print(f"Results written to: {output_file}")

# === Manual Testing Framework === #

def manual_testing_with_user_input(test_function, input_type):
    """Performs manual testing where the user provides inputs."""
    print(f"\nStarting manual testing for {test_function.__name__} with {input_type} inputs.")
    print("Enter 'q' to quit manual testing.")

    passed, failed = 0, 0
    failure_cases = []
    inputs_outputs = []
    array_testing_details = []  # To capture array details (type, contents)
    start_time = time.time()

    while True:
        try:
            # Prompt user for input
            user_input = input(f"Enter a {input_type} value: ")
            if user_input.lower() == 'q':
                break

            # Convert input to the correct type
            if input_type == "Integers":
                test_input = float(user_input)
                if test_input.is_integer():
                    test_input = int(test_input)  # Convert to int if it's a whole number
                else:
                    raise ValueError("Input is not an integer")
            elif input_type == "Strings":
                test_input = user_input
            elif input_type == "Arrays":
                try:
                    test_input = eval(user_input)  # e.g., "[1, 'a', 3]"
                    if not isinstance(test_input, list):
                        raise ValueError("Input is not a valid array")
                except:
                    raise ValueError("Invalid array format")
            else:
                print(f"Unsupported input type: {input_type}")
                continue

            # Test the function with the input
            output_val = test_function(test_input)
            inputs_outputs.append((user_input, "passed"))  # Storing input and status

            # Capture array testing details if it's an array input
            if input_type == "Arrays":
                array_testing_details.append(f"Input: {user_input}")
                array_testing_details.append(f"Homogeneous array of type: {type(test_input[0]).__name__}")
                array_testing_details.append(f"Array contents: {test_input}")
            
            print("Test passed.")
            passed += 1
        except Exception as e:
            print(f"Test failed with error: {e}")
            failed += 1
            inputs_outputs.append((user_input, "failed"))  # Storing input and status
            failure_cases.append((user_input, str(e)))

    end_time = time.time()

    return {
        "total": passed + failed,
        "passed": passed,
        "failed": failed,
        "failure_cases": failure_cases,
        "time_taken": end_time - start_time,
        "inputs_outputs": inputs_outputs,  # Storing manual test inputs and their status
        "array_testing_details": array_testing_details  # Storing array details
    }

# === Buggy Functions for Testing === #

def buggy_function_int(x):
    """
    A function that handles integer inputs, including:
    - Accepts negative integers
    - Correctly handles float representations of integers
    - Ensures input is a true integer
    """
    if isinstance(x, float):
        if x.is_integer():
            x = int(x)
        else:
            raise ValueError("Input must be a whole number")
    
    if not isinstance(x, int):
        raise ValueError("Input is not an integer")
    
    return x * 2


def buggy_function_string(s):
    """A buggy function for strings that raises an error for empty strings."""
    if s == "":
        raise ValueError("Empty string not allowed!")
    return len(s)

def buggy_function_array(arr):
    """
    Handles various types of arrays:
    - Integer Arrays: Arrays that contain only integers.
    - String Arrays: Arrays that contain only strings.
    - Float Arrays: Arrays that contain only floating-point numbers.
    - Boolean Arrays: Arrays that contain only boolean values (True or False).
    - Character Arrays: Arrays that contain characters (or letters).
    """
    try:
        processed_arr = list(arr)  # Ensure the input is processed as a list
    except TypeError:
        raise ValueError("Input must be an iterable (list, tuple, set, etc.)")

    if not processed_arr:
        return 0  # Return 0 for empty arrays

    try:
        array_types = set(type(item) for item in processed_arr)
        if len(array_types) == 1:
            type_name = list(array_types)[0].__name__
        else:
            type_names = [t.__name__ for t in array_types]
        
        if isinstance(processed_arr[0], int):  # Integer Array
            if all(isinstance(item, int) for item in processed_arr):
                pass
            else:
                raise ValueError("Array contains non-integer elements")
        
        elif isinstance(processed_arr[0], str):  # String Array
            if all(isinstance(item, str) for item in processed_arr):
                pass
            else:
                raise ValueError("Array contains non-string elements")
        
        elif isinstance(processed_arr[0], float):  # Float Array
            if all(isinstance(item, float) for item in processed_arr):
                pass
            else:
                raise ValueError("Array contains non-float elements")
        
        elif isinstance(processed_arr[0], bool):  # Boolean Array
            if all(isinstance(item, bool) for item in processed_arr):
                pass
            else:
                raise ValueError("Array contains non-boolean elements")
        
        elif isinstance(processed_arr[0], str) and len(processed_arr[0]) == 1:  # Character Array
            if all(isinstance(item, str) and len(item) == 1 for item in processed_arr):
                pass
            else:
                raise ValueError("Array contains non-character elements")

        return processed_arr  # Return the processed array (or total sum if needed)

    except Exception as e:
        raise


# === Main Execution === #

if __name__ == "__main__":
    output_dir = "test_results"
    os.makedirs(output_dir, exist_ok=True)

    input_generators = {
        "Integers": generate_random_integer,
        "Strings": generate_random_string,
        "Arrays": generate_random_array,
        "Booleans": generate_random_boolean
    }

    manual_results = {}
    manual_results["Integers"] = manual_testing_with_user_input(buggy_function_int, "Integers")
    manual_results["Strings"] = manual_testing_with_user_input(buggy_function_string, "Strings")
    manual_results["Arrays"] = manual_testing_with_user_input(buggy_function_array, "Arrays")

    evaluate_with_metrics(
        buggy_function_int,
        {"Integers": generate_random_integer},
        num_tests=150,
        output_dir=output_dir,
        manual_results=manual_results["Integers"]
    )
    evaluate_with_metrics(
        buggy_function_string,
        {"Strings": generate_random_string},
        num_tests=150,
        output_dir=output_dir,
        manual_results=manual_results["Strings"]
    )
    evaluate_with_metrics(
        buggy_function_array,
        {"Arrays": generate_random_array},
        num_tests=150,
        output_dir=output_dir,
        manual_results=manual_results["Arrays"]
    )
